---
layout: post
title: "Game development perfect guide"
date: 2025-09-03 19:00:00 +0900
categories: 
tags: ["Unity", "C#"]
---

ì´ˆê³ ì† ë³‘ë ¬ ì²˜ë¦¬ë¡œ êµ¬í˜„í•˜ëŠ” 3D ì˜¤ëª©(ìŠ¤í‚¬ í¬í•¨) ìŠ¹ë¦¬ íŒì • â€“ Unity C# Job System + Burst ì„¤ê³„ ë³´ê³ ì„œ (Transform ê¸°ë°˜ íƒìƒ‰ í¬í•¨)

í”Œë«í¼: Unity 2021.3+ (ë˜ëŠ” 2022/2023 LTS), .NET 4.x

í•µì‹¬ ê¸°ìˆ : C# Job System, Burst Compiler, Unity.Collections (NativeArray/NativeReference), Unity.Mathematics


---

1) ë°°ê²½ê³¼ ëª©í‘œ

3D ì˜¤ëª©ì€ ë³´ë“œê°€ NÃ—NÃ—N ì´ë©°, í•œ ìˆ˜ë¥¼ ë‘˜ ë•Œë§ˆë‹¤ 13ê°œ ë°©í–¥(ì¶• 3, ë©´ ëŒ€ê° 6, ê³µê°„ ëŒ€ê° 4)ì—ì„œ ì—°ì† ê°œìˆ˜ë¥¼ í™•ì¸í•´ì•¼ í•œë‹¤. ì—¬ê¸°ì— ìŠ¤í‚¬(ì˜ˆ: í•œ ê°œ ë¬´ì‹œ, ì™€ì¼ë“œì¹´ë“œ, ë°©í•´ëŒ, ì—°ì† ì œí•œ ì¦í­ ë“±)ì´ ë„ì…ë˜ë©´ ê³„ì‚°ëŸ‰ì´ ì¦ê°€í•œë‹¤.

ë³¸ ë³´ê³ ì„œëŠ” Unity ë©”ì¸ ìŠ¤ë ˆë“œ ë¹„ì˜ì¡´ ìˆœìˆ˜ ì—°ì‚°ìœ¼ë¡œ ìŠ¹ë¦¬ íŒì •ì„ ìˆ˜í–‰í•˜ê³ , Job System + Burstë¡œ ì´ˆê³ ì† ë³‘ë ¬í™”í•˜ëŠ” ì„¤ê³„/êµ¬í˜„ ì§€ì¹¨ì„ ì œì‹œí•œë‹¤. ì¶”ê°€ë¡œ, ë³´ë“œê°€ Unity Transform ê¸°ë°˜ìœ¼ë¡œ ë°°ì¹˜ëœ ê²½ìš° ë™ì¼í•œ ê°„ê²© ê±°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê°„ë‹¨í•˜ê²Œ íƒìƒ‰í•˜ëŠ” ë°©ë²•ë„ í¬í•¨í•œë‹¤.

ì„±ëŠ¥ ëª©í‘œ (ì§€í–¥)

ë‹¨ì¼ ìˆ˜ íŒì •: < 50Âµs @ N=15, ìŠ¤í‚¬ ë‹¨ìˆœ
(50Âµs = 0.00005ì´ˆ, ë§¤ìš° ì§§ì€ ê³„ì‚° ì‹œê°„ ë‹¨ìœ„ë¡œ, ì´ˆë³´ìëŠ” "ëˆˆ ê¹œì§í•  ì‚¬ì´ë³´ë‹¤ í›¨ì”¬ ë¹ ë¥¸ ì†ë„"ë¼ê³  ì´í•´í•˜ë©´ ë¨)

ë°°ì¹˜ íŒì •(ë™ì‹œ ë‹¤ìˆ˜ ìˆ˜/ì‹œë‚˜ë¦¬ì˜¤): ì„ í˜• í™•ì¥, 60FPS ìœ ì§€



---

2) ë°ì´í„° ëª¨ë¸ (Job System ë²„ì „)

2.1 ë³´ë“œ ì €ì¥ í˜•ì‹

NativeArray<int> 1ì°¨ì› ë°°ì—´, ê°’: 0=ë¹ˆì¹¸, 1=í‘, 2=ë°±, 3=ì™€ì¼ë“œì¹´ë“œ(ì˜µì…˜)

ì¸ë±ì‹±: idx = x + y*Size + z*Size*Size


struct Board3D
{
    public NativeArray<int> Cells; // length = Size*Size*Size
    public int Size;
    public int StrideY;
    public int StrideZ;

    public int Index(int x, int y, int z) => x + y*StrideY + z*StrideZ;
}

2.2 ìŠ¤í‚¬/ê·œì¹™ íŒŒë¼ë¯¸í„°

public struct SkillRules
{
    public int needed;
    public int skipAllowance;
    public int blockerValue;
    public bool treatWildcardAsAny;
}


---

3) ë°©í–¥ ë²¡í„° ì •ì˜ (13ê°œ)

static readonly int3[] Dirs = new int3[]
{
    new int3(1,0,0),  new int3(0,1,0),  new int3(0,0,1),
    new int3(1,1,0),  new int3(1,-1,0),
    new int3(1,0,1),  new int3(1,0,-1),
    new int3(0,1,1),  new int3(0,1,-1),
    new int3(1,1,1),  new int3(1,1,-1), new int3(1,-1,1), new int3(1,-1,-1)
};


---

4) ì•Œê³ ë¦¬ì¦˜ ê°œìš”

ë§ˆì§€ë§‰ ìˆ˜(last) ê¸°ì¤€ íŒì •ì„ ê¸°ë³¸ìœ¼ë¡œ í•œë‹¤. ê° ë°©í–¥ dì— ëŒ€í•´:

1. count = 1


2. +d ì „ì§„í•˜ë©° íŒì •


3. -d ì „ì§„í•˜ë©° íŒì •


4. count >= needed ë©´ ìŠ¹ë¦¬



ìŠ¤í‚¬ì€ íƒìƒ‰ ë£¨í”„ì— ìƒíƒœ ë¨¸ì‹ ìœ¼ë¡œ ë°˜ì˜í•œë‹¤.


---

5) Job System ì„¤ê³„ (ìš”ì•½)

ë‹¨ì¼ ìˆ˜ íŒì • â†’ IJob

ëŒ€ëŸ‰ íŒì • â†’ IJobParallelFor

Burst ì»´íŒŒì¼ëŸ¬ë¡œ ë²¡í„°í™”, ë¸Œëœì¹˜ ìµœì†Œí™”


(Job = ìœ ë‹ˆí‹°ì˜ ë©€í‹°ìŠ¤ë ˆë“œ ì‘ì—… ë‹¨ìœ„. IJobì€ ë‹¨ì¼ ì—°ì‚°, IJobParallelForëŠ” ë°°ì—´ì²˜ëŸ¼ ë°˜ë³µë˜ëŠ” í° ì‘ì—…ì„ ì—¬ëŸ¬ CPU ì½”ì–´ì—ì„œ ë‚˜ëˆ  ì‹¤í–‰í•˜ëŠ” ë°©ì‹)

> ì½”ë“œ ì˜ˆì‹œëŠ” ì› ë³´ê³ ì„œì— ìƒì„¸íˆ í¬í•¨ë¨.




---

6) Burst ìµœì í™” í¬ì¸íŠ¸

ë¸Œëœì¹˜ ìµœì†Œí™”, unsigned ê²½ê³„ ê²€ì‚¬
(ë¶„ê¸°ë¬¸ if/elseë¥¼ ì¤„ì´ë©´ CPUê°€ ëª…ë ¹ì–´ë¥¼ ë” ë¹ ë¥´ê²Œ ì‹¤í–‰í•  ìˆ˜ ìˆìŒ)

stride ê¸°ë°˜ ì—°ì† ë©”ëª¨ë¦¬ ì ‘ê·¼
(ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì— ì—°ì†ìœ¼ë¡œ ë°°ì¹˜í•˜ë©´ ìºì‹œ íš¨ìœ¨ì´ ì˜¬ë¼ê°€ ì†ë„ê°€ ë¹¨ë¼ì§)

ê·œì¹™ êµ¬ì¡°ì²´ ê°’ ì „ë‹¬
(Jobì— ê·œì¹™ì„ ê°’ìœ¼ë¡œ ë„˜ê¸°ë©´ ë§¤ë²ˆ ì°¸ì¡°í•˜ì§€ ì•Šì•„ë„ ë˜ì–´ ë” ë¹ ë¦„)

Release ë¹Œë“œì—ì„œ Safety Checks Off
(ì•ˆì „ ê²€ì‚¬ ê¸°ëŠ¥ì„ ë„ë©´ ì•½ê°„ ìœ„í—˜í•˜ì§€ë§Œ ì†ë„ê°€ í¬ê²Œ í–¥ìƒë¨)



---

7) Transform ê¸°ë°˜ ë‹¨ìˆœ íƒìƒ‰ ë°©ë²•

ë³´ë“œê°€ ì‹¤ì œ Unity Transform ì˜¤ë¸Œì íŠ¸ë¡œ ë°°ì¹˜ë¼ ìˆë‹¤ë©´, ê° ëŒì˜ Transform.positionì„ ì´ìš©í•´ ë™ì¼í•œ ê²©ì ê°„ê²©ìœ¼ë¡œ íƒìƒ‰í•  ìˆ˜ ìˆë‹¤.

ê¸°ë³¸ ì›ë¦¬

ê¸°ì¤€ ëŒ ìœ„ì¹˜ = origin

ë°©í–¥ ë²¡í„° = dir (ì •ê·œí™”)

ê°„ê²© ê±°ë¦¬ = cellSize

íƒìƒ‰ ë£¨í”„: pos = origin + dir * step * cellSize


ì˜ˆì‹œ ì½”ë“œ

bool CheckWinByTransform(Transform lastMove, int player, float cellSize, int needed)
{
    Vector3 origin = lastMove.position;

    foreach (var dir in directions) // 13ê°œ ë°©í–¥ ë‹¨ìœ„ ë²¡í„°
    {
        int count = 1;
        count += CountDirection(origin, dir, player, cellSize, needed - count);
        count += CountDirection(origin, -dir, player, cellSize, needed - count);
        if (count >= needed)
            return true;
    }
    return false;
}

int CountDirection(Vector3 origin, Vector3 dir, int player, float cellSize, int maxNeeded)
{
    int count = 0;
    for (int step = 1; step <= maxNeeded; step++)
    {
        Vector3 pos = origin + dir * step * cellSize;
        var stone = FindStoneAtPosition(pos); // ì¢Œí‘œâ†’ë³´ë“œ ë§¤í•‘ ìºì‹± ê¶Œì¥
        if (stone != null && stone.Player == player)
            count++;
        else
            break;
    }
    return count;
}

íŠ¹ì§•

êµ¬í˜„ ë‹¨ìˆœ, ì§ê´€ì 

Transform íƒìƒ‰ì„ ì§ì ‘ í•˜ë©´ ëŠë¦¬ë¯€ë¡œ ì¢Œí‘œâ†’ëŒ ë§¤í•‘ ìºì‹± í•„ìš”

Job System ë°©ì‹ê³¼ ë‹¬ë¦¬ ê°„ë‹¨ ê·œì¹™/ì†Œê·œëª¨ ë³´ë“œì— ì í•©



---

8) í…ŒìŠ¤íŠ¸ & ê²€ì¦ ê³„íš

Job System íŒì •ê³¼ Transform ê¸°ë°˜ íŒì • ê²°ê³¼ ì¼ì¹˜ ì—¬ë¶€ ê²€ì¦

ìŠ¤í‚¬ ê·œì¹™(ìŠ¤í‚µ, ì™€ì¼ë“œì¹´ë“œ, ì°¨ë‹¨ ëŒ ë“±) ì ìš© ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸

ì„±ëŠ¥ ë¹„êµ: Transform ë°©ì‹ì€ ì§ê´€ì ì´ì§€ë§Œ ëŒ€ê·œëª¨ ë³‘ë ¬ì—ëŠ” Job Systemì´ ìœ ë¦¬



---

9) ê²°ë¡ 

ìŠ¤í‚¬ í¬í•¨ 3D ì˜¤ëª© ìŠ¹ë¦¬ íŒì •ì€ Job System + Burstë¡œ ë³‘ë ¬í™”í•  ë•Œ ê°€ì¥ íš¨ìœ¨ì ì´ë‹¤.

ë‹¨ìˆœ/ì†Œê·œëª¨ ë³´ë“œì—ì„œëŠ” Transform ê¸°ë°˜ ë™ì¼ ê°„ê²© íƒìƒ‰ ë°©ì‹ìœ¼ë¡œ ê°„ë‹¨íˆ êµ¬í˜„ ê°€ëŠ¥í•˜ë‹¤.

í”„ë¡œì íŠ¸ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ ë‘ ë°©ì‹ì„ í˜¼í•© ì ìš© ê°€ëŠ¥í•˜ë‹¤.




ğŸ’¡ ì´ ê²Œì‹œê¸€ì€ GPTê°€ ì œì‘í–ˆìŠµë‹ˆë‹¤.

