---
layout: post
title: "Unity Optimization Habits: 주니어 개발자가 놓치기 쉬운 유니티 최적화 습관 3가지"
date: 2025-11-22 15:47:00 +0900
categories: 
tags:  ["Unity", "DevLog"]
---

## 주니어 개발자가 놓치기 쉬운 유니티 최적화 습관 3가지

게임 개발을 하다 보면 기능 구현에 집중하느라 퍼포먼스를 놓치는 경우가 많습니다. 특히 유니티(Unity)의 C\#은 편리한 기능(Garbage Collection 등)을 제공하지만, 그만큼 메모리 관리에서 주의가 필요합니다.

오늘은 기능 구현 단계에서 무의식적으로 작성하지만, 나중에 프레임 드랍(Frame Drop)의 주범이 될 수 있는 코드 패턴 3가지와 개선 방법을 정리해 봅니다.

### 1\. Update() 문에서의 문자열 연결 (String Concatenation)

UI에 점수나 타이머를 표시할 때 가장 흔하게 하는 실수입니다. C\#의 `string`은 불변(Immutable) 객체이기 때문에, 문자열을 더할 때마다 새로운 메모리를 할당하고 기존 메모리는 가비지(Garbage)가 됩니다.

**안 좋은 예 (Bad Case)**

```csharp
void Update() {
    // 매 프레임마다 새로운 문자열 객체가 생성됨 -> GC 호출 빈도 증가
    scoreText.text = "Current Score: " + currentScore.ToString();
}
```

**개선 방법 (Good Case)**
값이 변할 때만 갱신하거나, `StringBuilder`를 사용합니다. 단순한 UI 갱신이라면 아래와 같이 변경 감지 패턴을 사용하는 것이 좋습니다.

```csharp
private int _cachedScore = -1;

void Update() {
    if (_cachedScore != currentScore) {
        _cachedScore = currentScore;
        // 문자열 포맷팅도 최소화하거나 캐싱된 문자열 사용 권장
        scoreText.text = $"Current Score: {_cachedScore}"; 
    }
}
```

### 2\. 습관적인 LINQ 사용과 메모리 할당

LINQ는 가독성이 뛰어나고 데이터 처리에 강력하지만, 게임 루프(Game Loop) 내에서는 주의해서 사용해야 합니다. LINQ 쿼리는 내부적으로 대리자(Delegate)나 열거자(Enumerator) 객체를 생성하여 힙 메모리(Heap Memory)를 할당하기 때문입니다.

**안 좋은 예 (Bad Case)**

```csharp
void Update() {
    // 매 프레임마다 리스트를 순회하며 객체를 생성함
    var enemies = allGameObjects.Where(g => g.tag == "Enemy").ToList();
}
```

**개선 방법 (Good Case)**
`Update` 문이나 자주 호출되는 메서드에서는 일반적인 `for` 문이나 `foreach` 문을 사용하는 것이 성능상 훨씬 유리합니다. LINQ는 데이터 초기화 단계(`Start`, `Awake`)나 호출 빈도가 낮은 이벤트에서만 사용하는 것을 추천합니다.

### 3\. 태그 비교 (CompareTag) 활용하기

충돌 처리 등에서 오브젝트를 식별할 때 `tag` 프로퍼티를 직접 비교하는 경우가 많습니다. 하지만 `gameObject.tag`를 호출하면 내부적으로 문자열 복사가 발생할 수 있습니다(유니티 버전에 따라 다르지만, 가비지 생성을 피하는 것이 안전합니다).

**안 좋은 예 (Bad Case)**

```csharp
void OnCollisionEnter(Collision collision) {
    if (collision.gameObject.tag == "Player") { // 문자열 할당 발생 가능성
        // ...
    }
}
```

**개선 방법 (Good Case)**
유니티에서 제공하는 `CompareTag` 메서드는 최적화가 되어 있어 메모리 할당 없이 효율적으로 태그를 비교합니다.

```csharp
void OnCollisionEnter(Collision collision) {
    if (collision.gameObject.CompareTag("Player")) {
        // ...
    }
}
```

### 마치며: "최적화는 습관이다"

물론 "조기 최적화는 만악의 근원(Premature optimization is the root of all evil)"이라는 말도 있습니다. 기획이 수시로 바뀌는 프로토타이핑 단계에서는 가독성과 생산성이 우선입니다.

하지만 위에서 소개한 내용들은 **코드를 작성하는 순간의 작은 습관**들입니다. 이런 습관들이 모이면 나중에 대규모 리팩토링 없이도 쾌적한 게임 환경을 만들 수 있습니다.
