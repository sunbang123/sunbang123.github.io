---
layout: post
title: "포톤 퓨전2 공유모드 SimulationTime 동기화"
date: 2025-09-04 19:42:16 +0900
categories: 
tags: ["Unity", "C#", "SDK"]
---

# 포톤 퓨전2 공유모드 SimulationTime 기반 게임 시작 동기화 보고서

## 1. 서론

포톤 퓨전2의 공유모드(Shared Mode)는 기존의 클라이언트-서버 아키텍처와는 근본적으로 다른 접근 방식을 제공한다. 모든 클라이언트가 동등한 권한을 가지며, 특정 호스트에 의존하지 않는 분산 처리 환경을 구축할 수 있다. 이러한 환경에서 SimulationTime을 활용한 게임 시작 동기화는 매우 효과적이며 혁신적인 솔루션이다.

## 2. 포톤 퓨전2 공유모드의 아키텍처 이해

### 2.1 공유모드의 핵심 철학

공유모드는 전통적인 권위적 서버(Authoritative Server) 모델을 탈피하고, 모든 참여자가 평등하게 게임 상태를 관리하는 방식이다. 이는 P2P(Peer-to-Peer) 네트워크의 장점을 최대한 활용하면서도, 네트워크 게임에서 필수적인 일관성과 동기화를 보장한다.

### 2.2 InputAuthority vs StateAuthority

기존 클라이언트-서버 모델에서 사용되던 StateAuthority는 특정 서버가 모든 게임 상태를 관리하는 중앙집중형 방식이었다. 반면 공유모드의 InputAuthority는 각 객체나 시스템에 대해 특정 클라이언트가 입력과 제어 권한을 가지는 분산형 방식이다. 이로 인해 네트워크 트래픽이 분산되고, 단일 실패 지점(Single Point of Failure)이 제거된다.

### 2.3 분산 처리의 이점

공유모드에서는 각 클라이언트가 자신이 관리하는 객체들에 대해 직접적인 제어권을 가진다. 예를 들어, 플레이어 A는 자신의 캐릭터를, 플레이어 B는 자신의 캐릭터를 관리하며, 게임 매니저 같은 공통 객체는 특정 클라이언트가 담당할 수 있다. 이러한 분산 처리 방식은 전체적인 네트워크 성능을 향상시키고, 지연 시간을 줄인다.

## 3. SimulationTime의 심화 이해

### 3.1 틱 기반 시뮬레이션의 원리

포톤 퓨전의 SimulationTime은 단순한 시간 측정 도구가 아니라, 결정론적 게임 시뮬레이션의 핵심이다. 고정된 시간 간격(일반적으로 1/60초)으로 게임 상태를 업데이트함으로써, 모든 클라이언트에서 동일한 순서로 동일한 연산이 수행됨을 보장한다. 이는 부동소수점 연산의 오차나 프레임 레이트 변동으로 인한 불일치를 방지한다.

### 3.2 네트워크 지연 보상 메커니즘

퓨전2의 SimulationTime은 단순히 로컬 시간을 추적하는 것이 아니라, 네트워크 지연을 고려한 보정된 시간을 제공한다. 각 클라이언트는 자신의 네트워크 지연을 측정하고, 이를 기반으로 다른 클라이언트와의 시간을 동기화한다. 이 과정에서 예측(Prediction)과 보정(Reconciliation) 알고리즘이 복합적으로 작동한다.

### 3.3 결정론적 실행 보장

모든 클라이언트가 동일한 틱에서 동일한 입력을 처리하고 동일한 결과를 생성하는 것이 중요하다. SimulationTime은 이러한 결정론적 실행을 보장하는 타임스탬프 역할을 한다. 게임 시작 시점을 특정 틱으로 정의함으로써, 모든 후속 이벤트들이 정확히 동기화된 시간 기준으로 처리된다.

## 4. 클라이언트 기반 게임 시작 트리거의 혁신성

### 4.1 사용자 경험의 향상

전통적인 서버 중심 모델에서는 게임 시작을 위해 서버의 승인이나 특정 호스트의 결정이 필요했다. 공유모드에서는 모든 클라이언트가 게임 시작을 제안할 수 있어, 더욱 자연스럽고 즉각적인 게임 경험을 제공한다. 이는 특히 소규모 그룹이나 친구들 간의 게임에서 매우 유용하다.

### 4.2 네트워크 복원력

호스트 기반 시스템에서는 호스트가 연결을 잃으면 전체 게임이 중단될 수 있다. 공유모드에서는 게임 시작을 담당한 클라이언트가 나가더라도 게임은 계속 진행될 수 있으며, 다른 클라이언트가 필요한 관리 기능을 인수할 수 있다.

### 4.3 민주적 의사결정 구조

게임 시작뿐만 아니라 다양한 게임 이벤트나 결정을 여러 클라이언트가 제안하고 합의를 통해 처리할 수 있는 구조를 만들 수 있다. 이는 더욱 공정하고 투명한 멀티플레이어 게임 환경을 조성한다.

## 5. 구현 시 핵심 고려사항

### 5.1 중복 실행 방지 메커니즘

공유모드에서 여러 클라이언트가 동시에 같은 액션을 시도할 수 있으므로, 중복 실행을 방지하는 것이 중요하다. 이를 위해 상태 확인, 락 메커니즘, 또는 우선순위 기반 처리 등의 전략을 사용할 수 있다.

```csharp
// 핵심 구현 예제
[Networked] public int GameStartTick { get; set; } = -1;

[Rpc(RpcSources.InputAuthority, RpcTargets.All)]
public void StartGameRpc()
{
    if (GameStartTick == -1) // 중복 방지
    {
        GameStartTick = Runner.Tick;
        IsGameActive = true;
    }
}
```

### 5.2 상태 일관성 보장

모든 클라이언트가 동일한 게임 상태를 유지하는 것이 중요하다. 네트워크 변수(Networked Properties)와 RPC를 적절히 조합하여 상태 변화가 모든 참여자에게 정확히 전파되도록 해야 한다.

### 5.3 늦게 조인하는 플레이어 처리

게임이 이미 시작된 후에 새로운 플레이어가 참여하는 경우, 현재 게임 상태와 경과 시간을 정확히 전달해야 한다. 이는 단순한 시간 동기화를 넘어서 전체 게임 컨텍스트의 복원을 의미한다.

## 6. 성능 및 확장성 분석

### 6.1 네트워크 트래픽 최적화

공유모드에서는 중앙 서버로의 집중적인 트래픽이 없으므로, 전체적인 네트워크 대역폭 사용량이 더 효율적일 수 있다. 각 클라이언트는 자신이 관리하는 데이터만 브로드캐스트하므로, 불필요한 중복 전송이 줄어든다.

### 6.2 연산 부하 분산

게임 로직의 처리가 여러 클라이언트에 분산되므로, 단일 서버에 집중되는 연산 부하 문제가 해결된다. 이는 특히 복잡한 물리 시뮬레이션이나 AI 처리가 필요한 게임에서 큰 장점이 될 수 있다.

### 6.3 확장성 한계와 대안

공유모드는 일반적으로 소규모에서 중규모(2-16명) 멀티플레이어에 적합하다. 대규모 멀티플레이어에서는 여전히 전용 서버나 하이브리드 모델이 더 적절할 수 있으나, 특정 용도에서는 공유모드의 장점이 이러한 한계를 상쇄할 수 있다.

## 7. 실제 적용 사례 및 시나리오

### 7.1 협동 게임에서의 활용

4명이 함께 하는 협동 액션 게임에서, 모든 플레이어가 준비되면 아무나 게임을 시작할 수 있다. 이때 SimulationTime을 기준으로 한 동기화는 모든 플레이어가 정확히 동일한 순간에 게임을 시작할 수 있게 한다.

### 7.2 경쟁 게임에서의 공정성

1대1 대전 게임에서 양 플레이어가 모두 준비되면 자동으로 게임이 시작되고, 카운트다운이나 동시 액션이 필요한 상황에서 틱 기반 정확한 타이밍을 보장할 수 있다.

### 7.3 파티 게임에서의 유연성

여러 미니게임이 연속으로 이어지는 파티 게임에서, 각 게임의 시작을 다른 플레이어가 담당하면서도 일관된 타이밍 시스템을 유지할 수 있다.

## 8. 미래 발전 방향

### 8.1 AI 통합 가능성

공유모드의 분산 특성은 각 클라이언트가 로컬 AI를 실행하면서도 전체적인 게임 일관성을 유지하는 데 유리하다. 게임 시작 동기화 시스템은 AI 에이전트들의 활동 개시 시점도 정확히 조절할 수 있다.

### 8.2 크로스 플랫폼 최적화

다양한 플랫폼(PC, 모바일, 콘솔)에서 서로 다른 성능 특성을 가진 기기들이 함께 게임할 때, SimulationTime 기반 동기화는 하드웨어 차이를 극복하는 강력한 도구가 된다.

### 8.3 블록체인 통합 잠재력

분산형 아키텍처의 특성상, 향후 블록체인 기술과의 통합이 필요한 게임(NFT 게임, P2E 게임 등)에서도 자연스럽게 적용할 수 있는 구조를 제공한다.

## 9. 결론

포톤 퓨전2의 공유모드와 SimulationTime을 활용한 클라이언트 기반 게임 시작 동기화는 단순한 기술적 솔루션을 넘어서, 멀티플레이어 게임 개발의 패러다임을 변화시키는 혁신적 접근법이다. 

이 방식의 가장 큰 장점은 기술적 우수성과 사용자 경험의 개선이 동시에 달성된다는 점이다. 개발자는 복잡한 서버 관리나 호스트 마이그레이션 로직을 구현할 필요가 없으면서도, 플레이어들은 더욱 자연스럽고 즉각적인 게임 경험을 얻을 수 있다.

특히 현대 게임 시장에서 중요해지고 있는 사용자 주도적 경험, 공정한 게임 환경, 그리고 기술적 안정성을 모두 만족시킬 수 있는 솔루션으로서, 이 접근법은 향후 멀티플레이어 게임 개발의 표준이 될 가능성이 높다고 평가된다.

더 나아가, 이러한 분산형 게임 아키텍처는 현재 게임 산업이 직면하고 있는 서버 비용 문제, 글로벌 서비스의 지역적 제약, 그리고 중앙화된 서비스의 취약성 등을 근본적으로 해결할 수 있는 방향을 제시한다는 점에서 그 의미가 더욱 크다고 할 수 있다.