name: Fetch GitHub Commits
on:
  push:
    branches:
      - main 
    paths-ignore:
    - '_data/commits_data.json'
    
  workflow_dispatch: 
  schedule:
    - cron: '0 0 * * *' 
    
permissions:
  contents: write

jobs:
  fetch_and_save:
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.ACTIONS_DEPLOY_KEY }} 

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ssh-key: ${{ secrets.ACTIONS_DEPLOY_KEY }}
          fetch-depth: 0 

      - name: Install dependencies
        run: sudo apt-get install -y jq

      - name: Fetch and process commits
        id: fetch
        env:
          GITHUB_USERNAME: sunbang123
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REPOS_URL="https://api.github.com/users/${GITHUB_USERNAME}/repos?type=owner"
          
          # 레포지토리 목록 가져오기
          REPO_NAMES_RAW=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "$REPOS_URL")
          
          # API 응답 검증
          if echo "$REPO_NAMES_RAW" | jq -e '.[].name' > /dev/null 2>&1; then
              REPO_NAMES=$(echo "$REPO_NAMES_RAW" | jq -r '.[].name')
          else
              echo "Error: Failed to fetch repositories. Check username or API Rate Limit."
              echo "API Response: $REPO_NAMES_RAW"
              exit 1 
          fi
          
          # 임시 파일로 커밋 데이터 수집
          TEMP_COMMITS_FILE=$(mktemp)
          echo "[]" > "$TEMP_COMMITS_FILE"
          
          # 각 레포지토리의 커밋 가져오기
          for REPO_NAME in $REPO_NAMES; do
              echo "Processing repository: $REPO_NAME"
              COMMITS_URL="https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/commits?per_page=5"
              
              COMMITS_RAW_DATA=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "$COMMITS_URL")
              
              # 커밋 데이터 검증
              if echo "$COMMITS_RAW_DATA" | jq -e '.[0].sha' > /dev/null 2>&1; then
                  # 커밋 데이터를 배열로 변환 후 기존 데이터에 추가
                  COMMITS_ARRAY=$(echo "$COMMITS_RAW_DATA" | jq -c --arg repo "$REPO_NAME" '
                      [.[] | {
                          repo: $repo,
                          message: .commit.message, 
                          author: .commit.author.name, 
                          date: .commit.author.date,
                          sha: .sha
                      }]
                  ')
                  
                  # 배열 병합
                  jq -s '.[0] + .[1]' "$TEMP_COMMITS_FILE" <(echo "$COMMITS_ARRAY") > "${TEMP_COMMITS_FILE}.new"
                  mv "${TEMP_COMMITS_FILE}.new" "$TEMP_COMMITS_FILE"
              else
                  echo "Warning: Skipped repository $REPO_NAME (No commits or API error)."
              fi
          done
          
          # 날짜순으로 정렬 (최신순)
          FINAL_DATA=$(jq 'sort_by(.date) | reverse' "$TEMP_COMMITS_FILE")
          
          # 마지막 업데이트 시간 추가
          CURRENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          FINAL_WITH_TIME=$(echo "$FINAL_DATA" | jq --arg time "$CURRENT_TIME" '. + [{"last_updated": $time}]')
          
          # 결과 저장
          mkdir -p _data
          echo "$FINAL_WITH_TIME" > _data/commits_data.json
          
          # 임시 파일 삭제
          rm -f "$TEMP_COMMITS_FILE"
          
          echo "Successfully processed commits from all repositories."
          
      - name: Commit and push if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Automatic commit: Update recent GitHub activity data"
          file_pattern: _data/commits_data.json
         # skip_dirty_check: true
